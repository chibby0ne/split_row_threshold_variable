<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Creonic Simulation Environment (CSE): cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecse__lib.html">cse_lib</a>      </li>
      <li><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html">cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share Class Reference<br/>
<small>
[<a class="el" href="group__share.html">Share classes of the modules</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share" -->
<p>This is shared functionality for hardware compliant LDPC decoding.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vivado__dec__ldpc__bin__hw__share_8h_source.html">vivado_dec_ldpc_bin_hw_share.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.png" usemap="#cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share_map" alt=""/>
  <map id="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share_map" name="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share_map">
<area href="classcse__lib_1_1Vivado__Decoder__LDPC__IEEE__802__11ad.html" alt="cse_lib::Vivado_Decoder_LDPC_IEEE_802_11ad" shape="rect" coords="0,56,306,80"/>
</map>
</div>

<p><a href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a0ba144e57101c2149abb2ce28a6bd28d">CHECK_NODE_ENUM</a> { <a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a0ba144e57101c2149abb2ce28a6bd28da973b50cd40505f1e6fc5d0ebcf162dc5">LAMBDA_MIN</a>, 
<a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a0ba144e57101c2149abb2ce28a6bd28dad2dbc3a7ebb51539a0bb40c9f1762200">MIN_SUM</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>LDPC check node algorithms. </p>
 <a href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a0ba144e57101c2149abb2ce28a6bd28d">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a9e42feef83e24b092c7a262f618bfc6d">Saturate_Value</a> (int &amp;input, unsigned int max_magnitude)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple saturation function.  <a href="#a9e42feef83e24b092c7a262f618bfc6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cfb2e3bd84f3765a0b9eb37579b80f4"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Saturate_Value" ref="a4cfb2e3bd84f3765a0b9eb37579b80f4" args="(int &amp;input, int max_value, int min_value)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a4cfb2e3bd84f3765a0b9eb37579b80f4">Saturate_Value</a> (int &amp;input, int max_value, int min_value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saturate the given signed value in place to the given maximum and minimum values. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56b6d224a0af8109a0a5361ba75f9afd"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Check_Node_Group_Min_Sum" ref="a56b6d224a0af8109a0a5361ba75f9afd" args="(unsigned int cng_counter, int in_out_msg[], float esf_factor, bool check_node_partitioned[])" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>Check_Node_Group_Min_Sum</b> (unsigned int cng_counter, int in_out_msg[], float esf_factor, bool check_node_partitioned[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#acc4a867a4ce55366a2583b7529287c66">Check_Node_Min_Sum</a> (int in_out_msg[], float esf_factor)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check node implementation according to Min-Sum algorithm.  <a href="#acc4a867a4ce55366a2583b7529287c66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#ac4dbba68069b565e850a2ec784789c81">Init_APP_RAM</a> (int input_bits_llr[NUM_VARIABLE_NODES], int app_ram[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy input data to LDPC decoder RAMs.  <a href="#ac4dbba68069b565e850a2ec784789c81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a6e839f11e600ef1f4c8ca48466a8c0e1">Read_APP_RAM</a> (int app_ram[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM], int iter, int output_bits_llr_app[NUM_MAX_ITERATIONS][NUM_VARIABLE_NODES], unsigned int output_bits[NUM_MAX_ITERATIONS][NUM_VARIABLE_NODES])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy LDPC decoder RAMs deinterleaved to output arrays.  <a href="#a6e839f11e600ef1f4c8ca48466a8c0e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a8d3be9d05f72dcae44a0e8da4be08bf7">Calc_Modified_Systematic_Bits</a> (unsigned int iter, int input_bits_llr[NUM_VARIABLE_NODES], unsigned int output_bits[NUM_MAX_ITERATIONS][NUM_VARIABLE_NODES])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the number of systematic bits that have been swapped during decoding.  <a href="#a8d3be9d05f72dcae44a0e8da4be08bf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a5d3f3bdf6deaddf31593500ad6c64b1a">Decode_Two_Phase</a> (int app_ram[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM], int msg_ram[DST_PARALLELISM][NUM_CHECK_NODES *MAX_CHECK_DEGREE/DST_PARALLELISM], int input_bits_llr[NUM_VARIABLE_NODES], unsigned int iter, bool check_node_partitioned[], bool app_parity_check=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two-Phase LDPC decoder function. Each call corresponds to a single iteration.  <a href="#a5d3f3bdf6deaddf31593500ad6c64b1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a9e569aa581b908d15ba269ca9b36347e">Get_Check_Node_Input</a> (int app_ram[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM], int msg_ram[DST_PARALLELISM][NUM_CHECK_NODES *MAX_CHECK_DEGREE/DST_PARALLELISM], unsigned int iter, unsigned int cng_counter, unsigned int cfu_counter, int check_node_in[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function retrieve extrinsic values to feed the chcek nodes with.  <a href="#a9e569aa581b908d15ba269ca9b36347e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#ac4f58586f839cdef815a92e6556d00ad">Write_Check_Node_Output</a> (int app_ram[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM], int msg_ram[DST_PARALLELISM][NUM_CHECK_NODES *MAX_CHECK_DEGREE/DST_PARALLELISM], unsigned int iter, unsigned int cng_counter, unsigned int cfu_counter, int check_node_out[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to write back APP values to app_ram.  <a href="#ac4f58586f839cdef815a92e6556d00ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#ae643930c91de2bc2ab175b5c43845489">Calc_Parity_Check</a> (int values[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate parity check in input buffer.  <a href="#ae643930c91de2bc2ab175b5c43845489"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88b80cccf5d9ca18c4ee3718b47f39ff"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::num_lambda_min_" ref="a88b80cccf5d9ca18c4ee3718b47f39ff" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a88b80cccf5d9ca18c4ee3718b47f39ff">num_lambda_min_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of messages to take in account for lambda-min algorithm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b3cb1ea2cde458b169ba8cb64c2f4c2"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::esf_factor_" ref="a7b3cb1ea2cde458b169ba8cb64c2f4c2" args="" -->
float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a7b3cb1ea2cde458b169ba8cb64c2f4c2">esf_factor_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrinsic scaling factor for Min-Sum algorithm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd978c0b29b4725d696f6d80fe3fda48"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::max_msg_extr_" ref="abd978c0b29b4725d696f6d80fe3fda48" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#abd978c0b29b4725d696f6d80fe3fda48">max_msg_extr_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum value of extrinsic information. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85c4651e7260e9100003976b0d751970"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::max_msg_app_" ref="a85c4651e7260e9100003976b0d751970" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a85c4651e7260e9100003976b0d751970">max_msg_app_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum value of APP values. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd7bc8fdbc57d5b071161c4bdad25a0c"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::num_variable_nodes_" ref="afd7bc8fdbc57d5b071161c4bdad25a0c" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#afd7bc8fdbc57d5b071161c4bdad25a0c">num_variable_nodes_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of variable nodes of the code (= N). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13071813b9ca745bd4ff7f11c1b224b1"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::num_check_nodes_" ref="a13071813b9ca745bd4ff7f11c1b224b1" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a13071813b9ca745bd4ff7f11c1b224b1">num_check_nodes_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of check nodes of the code (= N - K = M). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebc9934adc3de6233a72a1cbe41e13d7"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::max_check_degree_" ref="aebc9934adc3de6233a72a1cbe41e13d7" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#aebc9934adc3de6233a72a1cbe41e13d7">max_check_degree_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum check node degree of the code. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee0b7da4e4757b5213084323c94af955"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::src_parallelism_" ref="aee0b7da4e4757b5213084323c94af955" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#aee0b7da4e4757b5213084323c94af955">src_parallelism_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallelism of the base matrix as defined in the standard, i.e., submatrix size. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87040ce1e0b1784bbae9d35eb9b29d66"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::is_IRA_code_" ref="a87040ce1e0b1784bbae9d35eb9b29d66" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a87040ce1e0b1784bbae9d35eb9b29d66">is_IRA_code_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IRA codes have only parity nodes of degree two and one parity node of degree one. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2afd9b42bb6d4c672c12539344353869"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::addr_vector_" ref="a2afd9b42bb6d4c672c12539344353869" args="" -->
const int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a2afd9b42bb6d4c672c12539344353869">addr_vector_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the address vector of the currently processed code. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eed8d2e573d6bceb36470609b9e5fe2"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::shft_vector_" ref="a3eed8d2e573d6bceb36470609b9e5fe2" args="" -->
const int *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a3eed8d2e573d6bceb36470609b9e5fe2">shft_vector_</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the shift vector of the currently processed code. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ee236307bafd1a9c937961ae8935f3d"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::check_node_algorithm_" ref="a4ee236307bafd1a9c937961ae8935f3d" args="" -->
static const <a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a0ba144e57101c2149abb2ce28a6bd28d">CHECK_NODE_ENUM</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a4ee236307bafd1a9c937961ae8935f3d">check_node_algorithm_</a> = MIN_SUM</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check node algorithm. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cff2cf3677823df644f03be79c34779"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::bw_fract_" ref="a4cff2cf3677823df644f03be79c34779" args="" -->
static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a4cff2cf3677823df644f03be79c34779">bw_fract_</a> = BW_FRACT</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of bits for fractional part of all values. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ae6743293ad94d554860e86afcd969a"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::dst_parallelism_" ref="a6ae6743293ad94d554860e86afcd969a" args="" -->
static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a6ae6743293ad94d554860e86afcd969a">dst_parallelism_</a> = DST_PARALLELISM</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Currently implemented parallelism of the code, i.e., actual decoder parallelism. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This is shared functionality for hardware compliant LDPC decoding. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a0ba144e57101c2149abb2ce28a6bd28d"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::CHECK_NODE_ENUM" ref="a0ba144e57101c2149abb2ce28a6bd28d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcse__lib_1_1Vivado__Decoder__LDPC__Binary__HW__Share.html#a0ba144e57101c2149abb2ce28a6bd28d">cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::CHECK_NODE_ENUM</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LDPC check node algorithms. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0ba144e57101c2149abb2ce28a6bd28da973b50cd40505f1e6fc5d0ebcf162dc5"></a><!-- doxytag: member="LAMBDA_MIN" ref="a0ba144e57101c2149abb2ce28a6bd28da973b50cd40505f1e6fc5d0ebcf162dc5" args="" -->LAMBDA_MIN</em>&nbsp;</td><td>
<p>Lambda-Min, where lambda is given by num_lambda_min </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0ba144e57101c2149abb2ce28a6bd28dad2dbc3a7ebb51539a0bb40c9f1762200"></a><!-- doxytag: member="MIN_SUM" ref="a0ba144e57101c2149abb2ce28a6bd28dad2dbc3a7ebb51539a0bb40c9f1762200" args="" -->MIN_SUM</em>&nbsp;</td><td>
<p>Min-Sum decoding, with extrinsic scaling factor esf_factor </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a8d3be9d05f72dcae44a0e8da4be08bf7"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Calc_Modified_Systematic_Bits" ref="a8d3be9d05f72dcae44a0e8da4be08bf7" args="(unsigned int iter, int input_bits_llr[NUM_VARIABLE_NODES], unsigned int output_bits[NUM_MAX_ITERATIONS][NUM_VARIABLE_NODES])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Calc_Modified_Systematic_Bits </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>input_bits_llr</em>[NUM_VARIABLE_NODES], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>output_bits</em>[NUM_MAX_ITERATIONS][NUM_VARIABLE_NODES]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the number of systematic bits that have been swapped during decoding. </p>
<p>Compares input and output buffers of the decoder and calculates how many bits have been swapped during decoding (hard).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>The iteration to check for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>input_bits_llr</em>&nbsp;</td><td>The input llr values of the LDPC decoder, linear order. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output_bits</em>&nbsp;</td><td>The hard decoded bits of the LDPC decoder, for each iteration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae643930c91de2bc2ab175b5c43845489"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Calc_Parity_Check" ref="ae643930c91de2bc2ab175b5c43845489" args="(int values[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Calc_Parity_Check </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>values</em>[]</td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate parity check in input buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td><a class="el" href="classBuffer.html" title="Buffer class with type and optional dimension as template parameter.">Buffer</a> to calculate parity check on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 : Parity check was not satisfied. </dd>
<dd>
0 : Parity check was satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="acc4a867a4ce55366a2583b7529287c66"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Check_Node_Min_Sum" ref="acc4a867a4ce55366a2583b7529287c66" args="(int in_out_msg[], float esf_factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Check_Node_Min_Sum </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>in_out_msg</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>esf_factor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check node implementation according to Min-Sum algorithm. </p>
<p>This function takes quantized values and performs the check node operation according to the Min-Sum approximation. The extrinsic scaling factor esf_factor is used for output scaling.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>in_out_msg[]</em>&nbsp;</td><td>Input/Output array of messages to/from the check node. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>esf_factor</em>&nbsp;</td><td>Extrinsic scaling factor: Supported are 0.75 and 0.875.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 : Parity check was not satisfied. </dd>
<dd>
1 : Parity check was satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d3f3bdf6deaddf31593500ad6c64b1a"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Decode_Two_Phase" ref="a5d3f3bdf6deaddf31593500ad6c64b1a" args="(int app_ram[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM], int msg_ram[DST_PARALLELISM][NUM_CHECK_NODES *MAX_CHECK_DEGREE/DST_PARALLELISM], int input_bits_llr[NUM_VARIABLE_NODES], unsigned int iter, bool check_node_partitioned[], bool app_parity_check=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Decode_Two_Phase </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>app_ram</em>[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msg_ram</em>[DST_PARALLELISM][NUM_CHECK_NODES *MAX_CHECK_DEGREE/DST_PARALLELISM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>input_bits_llr</em>[NUM_VARIABLE_NODES], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>check_node_partitioned</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>app_parity_check</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Two-Phase LDPC decoder function. Each call corresponds to a single iteration. </p>
<p>This function contains the LDPC decoder itself. Each call corresponds to a single decoder iteration. So calling this function in a loop will result in the normal LDPC decoding process. The memories can be accessed after each iteration. The decoder returns the number of parity checks that were satisfied which allows to stop the decoding process when all parity checks are satisfied.</p>
<p>This particular function corresponds to hardware-compliant decoding with a two-phase scheduling. All check nodes work on the same data and no early update occurs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>app_ram</em>&nbsp;</td><td><a class="el" href="classBuffer.html" title="Buffer class with type and optional dimension as template parameter.">Buffer</a> of two dimensional memory array storing the quantized APP LLR values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_ram</em>&nbsp;</td><td><a class="el" href="classBuffer.html" title="Buffer class with type and optional dimension as template parameter.">Buffer</a> of two dimensional memory array storing the extrinsic information (can be uninitialized for the first iteration). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>The iteration the decoder currently processes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>app_parity_check</em>&nbsp;</td><td>Defines whether to use APP values or extrinsic values for calculation of the parity check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of parity checks that were satisfied. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e569aa581b908d15ba269ca9b36347e"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Get_Check_Node_Input" ref="a9e569aa581b908d15ba269ca9b36347e" args="(int app_ram[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM], int msg_ram[DST_PARALLELISM][NUM_CHECK_NODES *MAX_CHECK_DEGREE/DST_PARALLELISM], unsigned int iter, unsigned int cng_counter, unsigned int cfu_counter, int check_node_in[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Get_Check_Node_Input </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>app_ram</em>[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msg_ram</em>[DST_PARALLELISM][NUM_CHECK_NODES *MAX_CHECK_DEGREE/DST_PARALLELISM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>cng_counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>cfu_counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>check_node_in</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function retrieve extrinsic values to feed the chcek nodes with. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>app_ram</em>&nbsp;</td><td><a class="el" href="classBuffer.html" title="Buffer class with type and optional dimension as template parameter.">Buffer</a> to read APP values from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_ram</em>&nbsp;</td><td>Extrinsic storage to read check node data from previous iteration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>Current decoder iteration (starting from 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cng_counter</em>&nbsp;</td><td>Check node group counter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cfu_counter</em>&nbsp;</td><td>Check node functional unit counter (within the check node group) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check_node_in</em>&nbsp;</td><td>Values that are going to the check node </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>app_out</em>&nbsp;</td><td>APP values that were used to calculate the check node input data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4dbba68069b565e850a2ec784789c81"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Init_APP_RAM" ref="ac4dbba68069b565e850a2ec784789c81" args="(int input_bits_llr[NUM_VARIABLE_NODES], int app_ram[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Init_APP_RAM </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>input_bits_llr</em>[NUM_VARIABLE_NODES], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>app_ram</em>[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy input data to LDPC decoder RAMs. </p>
<p>Function that initializes the int app_ram_ with the quantized values stored in input_bits_llr(). The operation performs the interleaving that is dependant on the decoder parallelism. This function has to be called once before the decoder function decode_xxx() can be called for the first time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input_bits_llr</em>&nbsp;</td><td>LLR values of the codeword in linear order. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>app_ram</em>&nbsp;</td><td><a class="el" href="classBuffer.html" title="Buffer class with type and optional dimension as template parameter.">Buffer</a> to store LLR values as in hardware decoder. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e839f11e600ef1f4c8ca48466a8c0e1"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Read_APP_RAM" ref="a6e839f11e600ef1f4c8ca48466a8c0e1" args="(int app_ram[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM], int iter, int output_bits_llr_app[NUM_MAX_ITERATIONS][NUM_VARIABLE_NODES], unsigned int output_bits[NUM_MAX_ITERATIONS][NUM_VARIABLE_NODES])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Read_APP_RAM </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>app_ram</em>[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>output_bits_llr_app</em>[NUM_MAX_ITERATIONS][NUM_VARIABLE_NODES], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>output_bits</em>[NUM_MAX_ITERATIONS][NUM_VARIABLE_NODES]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy LDPC decoder RAMs deinterleaved to output arrays. </p>
<p>This function has to be called when the soft information or the hard decoded bits after decoding have to be read. This can happen after each decoder iteration. If only the result after the maximum number of iterations is of interested calling only once is sufficient. Deinterleaving according to the decoder parallelism is performed and either a 0 or a 1 is stored for the hard decoded bits. Modifies output_bits() and output_bits_llr_app().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>app_ram</em>&nbsp;</td><td>Two-dimensional <a class="el" href="classBuffer.html" title="Buffer class with type and optional dimension as template parameter.">Buffer</a> containing APP values after decoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>Current LDPC decoder iteration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e42feef83e24b092c7a262f618bfc6d"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Saturate_Value" ref="a9e42feef83e24b092c7a262f618bfc6d" args="(int &amp;input, unsigned int max_magnitude)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Saturate_Value </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>max_magnitude</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simple saturation function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>Pointer to Input/Output value to saturate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_value</em>&nbsp;</td><td>Magnitude of maximum value that is allowed. Saturate the given signed value in place to the given magnitude. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4f58586f839cdef815a92e6556d00ad"></a><!-- doxytag: member="cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Write_Check_Node_Output" ref="ac4f58586f839cdef815a92e6556d00ad" args="(int app_ram[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM], int msg_ram[DST_PARALLELISM][NUM_CHECK_NODES *MAX_CHECK_DEGREE/DST_PARALLELISM], unsigned int iter, unsigned int cng_counter, unsigned int cfu_counter, int check_node_out[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cse_lib::Vivado_Decoder_LDPC_Binary_HW_Share::Write_Check_Node_Output </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>app_ram</em>[DST_PARALLELISM][NUM_VARIABLE_NODES/DST_PARALLELISM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msg_ram</em>[DST_PARALLELISM][NUM_CHECK_NODES *MAX_CHECK_DEGREE/DST_PARALLELISM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>cng_counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>cfu_counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>check_node_out</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to write back APP values to app_ram. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>app_ram</em>&nbsp;</td><td><a class="el" href="classBuffer.html" title="Buffer class with type and optional dimension as template parameter.">Buffer</a> to write APP values to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_ram</em>&nbsp;</td><td>Extrinsic storage to write check node data into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>Current decoder iteration (starting from 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cng_counter</em>&nbsp;</td><td>Check node group counter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cfu_counter</em>&nbsp;</td><td>Check node functional unit counter (within the check node group) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check_node_out</em>&nbsp;</td><td><a class="el" href="classBuffer.html" title="Buffer class with type and optional dimension as template parameter.">Buffer</a> holding the information of the check node we processed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/net/user/r1/unix/schlaefer/projects/cse/library/modules/decoder/<a class="el" href="vivado__dec__ldpc__bin__hw__share_8h_source.html">vivado_dec_ldpc_bin_hw_share.h</a></li>
<li>/net/user/r1/unix/schlaefer/projects/cse/library/modules/decoder/<a class="el" href="vivado__dec__ldpc__bin__hw__share_8cpp.html">vivado_dec_ldpc_bin_hw_share.cpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
