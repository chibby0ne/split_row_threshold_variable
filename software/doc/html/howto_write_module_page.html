<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Creonic Simulation Environment (CSE): How to write a new functional module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>How to write a new functional module </h1>  </div>
</div>
<div class="contents">
<p>Before starting to implement or convert existing code to a new module, please read the <a class="el" href="chain_concept_page.html#general_module_concept">Functional Module Concept</a> chapter. The chapter explain the design idea behind the software.</p>
<p>For writing new modules for the simulation you have to do the following steps:</p>
<ul>
<li><a class="el" href="howto_write_module_page.html#create_param">Create a parameter class for the module</a> </li>
<li><a class="el" href="howto_write_module_page.html#interface_class">Choosing or writing an interface class</a> </li>
<li><a class="el" href="howto_write_module_page.html#classcoding">Writing the module class itself</a> </li>
<li><a class="el" href="howto_write_module_page.html#doc">Documentation of the Module</a></li>
</ul>
<p>In the following these steps are explained in more detail at the example of a hardware-compliant LDPC decoder model.</p>
<h2><a class="anchor" id="create_param"></a>
Create a parameter class for the module</h2>
<p>In a first step it is necessary to generate the parameter class that corresponds to the module we want to implement. This parameter class contains all parameters that are needed by the decoder to run. In the example these are things like quantization, scheduling, number of iteration, etc. The parameter class is derived from the class Base_Parameter.</p>
<p>The empty parameter class looks as follows:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifndef DEC_LDPC_BINARY_HW_PARAM_H_</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEC_LDPC_BINARY_HW_PARAM_H_</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &quot;../base/base_param.h&quot;</span>


<span class="keyword">class </span>Decoder_LDPC_Binary_HW_Parameter : <span class="keyword">public</span> Base_Parameter
{

<span class="keyword">public</span>:

  Decoder_LDPC_Binary_HW_Parameter()
  {
    instance_name(Unique_ID());
    Set_Default_Values();
  }

  <span class="keyword">virtual</span> ~Decoder_LDPC_Binary_HW_Parameter() { }

  <span class="keyword">static</span> <span class="keywordtype">string</span> Unique_ID(){ <span class="keywordflow">return</span> <span class="stringliteral">&quot;Decoder_LDPC_Binary_HW&quot;</span>;}

<span class="keyword">protected</span>:
  

};
<span class="preprocessor">#endif</span>
</pre></div><p>The parameter header files have the suffix "_param.h", thus this code is stored in the file dec_ldpc_binary_hw_param.h. The include directives have to contain relative paths to the lib directory for the base and the assistance directories. By default, the instance name should be equal to the name of the module class.</p>
<h2><a class="anchor" id="add_param"></a>
Adding parameters to the class</h2>
<p>Parameters for the modules are added to the public part of the class (shown in the following for the quantization parameters). Use Doxygen comments here (triple slash). All parameters have to use the container class Param.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">public</span>:
  ....

  Param&lt;unsigned int&gt; bw_chv;

  Param&lt;unsigned int&gt; bw_fract;

  Param&lt;unsigned int&gt; num_iter;
  
  <span class="keyword">enum</span> DEC_TYPE_ENUM {MIN_SUM, BP};
  Param&lt;DEC_TYPE_ENUM&gt; dec_algo;
  
  ...
</pre></div><p>Use the bw_ prefix to indicate that the parameter is used to set a quantization value (bw = bit-width). Use the num_ prefix for countable things (num_info_bits, num_bits_per_symbol, ...).</p>
<p>The <a class="el" href="classcse__lib_1_1Param.html" title="Template class to store parameter for the modules.">cse_lib::Param</a> container class provides the () operator to set or get a value. Therefore the implementation of accessor functions is not necessary.</p>
<h2><a class="anchor" id="param_default"></a>
Initialization of parameters</h2>
<p>In order to set these values to appropriate values, the function Set_Default_Values() is called from within the constructor. This function is defined in the protected part and uses the <a class="el" href="classcse__lib_1_1Param.html#a2d192190afd8ef831e8319ef0cff4d26" title="Initialize the parameter class to use in a module.">cse_lib::Param::Init</a>-function of the <a class="el" href="classcse__lib_1_1Param.html" title="Template class to store parameter for the modules.">cse_lib::Param</a>-container: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">protected</span>:


  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Set_Default_Values()
  {
    bw_chv.Init(6, <span class="stringliteral">&quot;bw_chv&quot;</span>, param_list_);
    bw_fract.Init(2, <span class="stringliteral">&quot;bw_fract&quot;</span>, param_list_);
    num_iter.Init(10, <span class="stringliteral">&quot;num_iter&quot;</span>, param_list_);
    dec_algo.Init(MIN_SUM, <span class="stringliteral">&quot;Decoding algorithm&quot;</span>, param_list_);
  }
</pre></div><p>The first parameter of the <a class="el" href="classcse__lib_1_1Param.html#a2d192190afd8ef831e8319ef0cff4d26" title="Initialize the parameter class to use in a module.">cse_lib::Param::Init</a> function gives the default value for the parameter. The second parameter describes the parameter by a string which is used for the output and for detection of the parameter in a configuration structure like XML. <b>This string is required to be set to the name of the variable.</b> The last parameter is a list object, which is inherently available from the parent class Base_Parameter. Registering each parameter in this list enables some comfort functionalities like printing all parameters by using the streaming operator (&lt;&lt;) on a module object or automatic configuration of the module.</p>
<p><b>Document the Set_Default_Values() method with doxygen comments that state the default values for the module! Only then the user knows about the default values from the documentation!</b></p>
<h2><a class="anchor" id="auto_conf"></a>
Add Automatic Configuration Capability</h2>
<p>By default, the modules are able to configure themselves without any further code. The <a class="el" href="classcse__lib_1_1Base__Parameter.html" title="Base of the parameter classes for the modules.">cse_lib::Base_Parameter</a> class offers the function Config_From_Data_Struct() which reads the values of all parameters that are stored in the list param_list_ (see above).</p>
<p>The function is able to read the data types bool, int, float, double, long long int, and string. For int values it is possible to use prefixes like "0x" or 0o".</p>
<p>Enum types are not included inherently. They are treated like strings, but the strings have to be linked to the enum type. The string should be equal to the enum-name, such that when reading the Doxygen documentation it is possible to determine the possible configuration values. Append the following lines to the Set_Default_Values method to link the enum values with a string: </p>
<div class="fragment"><pre class="fragment">  ...
  dec_algo.Link_Value_String(MIN_SUM, <span class="stringliteral">&quot;MIN_SUM&quot;</span>);
  dec_algo.Link_Value_String(BP, <span class="stringliteral">&quot;BP&quot;</span>);
  ...
</pre></div><p>Note, that it is also possible to implement an own Config_From_Data_Struct-function. In the _Parameter class. This can be useful, when some parameters are required only for certain configurations. But the default is to use the function of the <a class="el" href="classcse__lib_1_1Base__Parameter.html" title="Base of the parameter classes for the modules.">cse_lib::Base_Parameter</a>.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">public</span>:
  ...
  
  <span class="keywordtype">void</span> Config_From_Data_Struct(<a class="code" href="classConfig__Data__Structure.html" title="Abstract interface class to hold the configuration tree for one module.">Config_Data_Structure</a>&amp; config_tree)
  {
    bw_chv.Set_By_Data_Struct(config_tree);
    bw_fract.Set_By_Data_Struct(config_tree);
    num_iter.Set_By_Data_Struct(config_tree);
    <span class="keywordflow">if</span> (bw_chv == 6)
        some_parameter.Set_By_Data_Struct(config_tree);
    ...
  }

  ...
</pre></div><p>The parameter class for the module is complete now.</p>
<h2><a class="anchor" id="interface_class"></a>
Choosing or writing an interface class</h2>
<p>The framework provides a lot of interface classes for different types of modules. If your new module matches one of these types, you do not have to write a new interface class. If that is not the case, you have to write a new interface class, but it consists of only a few lines of code:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifndef DEC_LDPC_BINARY_HW_IFACE_H_</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEC_LDPC_BINARY_HW_IFACE_H_</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &quot;../base/base_iface.h&quot;</span>

<span class="keyword">class </span>Decoder_LDPC_Binary_HW_Interface : <span class="keyword">public</span> Base_Interface
{

<span class="keyword">public</span>:

    Decoder_LDPC_Binary_HW_Interface()
    {
      input_llr.Register(<span class="stringliteral">&quot;input_llr&quot;</span>, input_data_list_);
      output_bits.Register(<span class="stringliteral">&quot;output_bits&quot;</span>, output_data_list_);
    }

    <span class="keyword">virtual</span> ~Decoder_LDPC_Binary_HW_Interface() {}

    Data_In&lt;int&gt; input_bits_llr;
    
    Data_Out&lt;unsigned int&gt; output_bits;

};
<span class="preprocessor">#endif // DEC_LDPC_BINARY_HW_IFACE_H_</span>
</pre></div><p>This class defines the input and output ports with the two containers Data_In and Data_Out. Similar to the parameter class, this container provides the () operator to access the data. The input_data_list_ and the output_data_list_ hold all data I/O objects. These lists are necessary for the automatic connection feature of the simulation chain. The header file has the suffix "_iface".</p>
<p>Naming of the ports has to comply to the rules as shown in <a class="el" href="naming_guidelines_page.html#naming_ports">Naming of input and output data ports of the modules</a>.</p>
<p>Besides data ports, the module can also offer status information using the Status_Out container:</p>
<div class="fragment"><pre class="fragment">
    Status_Out&lt;unsigned int&gt; num_iterations;
    
    Status_Out&lt;bool&gt; decoding_successful;
</pre></div><p>The Status_Out container allows for calculation of statistics. For more information, please refer to <a class="el" href="howto_use_status_out_page.html">How to use the Status_Out interface container</a>.</p>
<h2><a class="anchor" id="classcoding"></a>
Writing the module class itself</h2>
<p>After we created the parameter class and made sure that we are able to parse the XML file, it is time to write the code for the module. For that we have to write two files: </p>
<ul>
<li>The header file containing the class definition </li>
<li>The cpp file containing the functionality of the class</li>
</ul>
<h2><a class="anchor" id="header_file"></a>
The module class definition (header)</h2>
<p>As mentioned before, each module is derived from at least two classes: the interface and the parameter class. In our example the default class definition looks as follows:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifndef DEC_LDPC_BINARY_HW_H_</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEC_LDPC_BINARY_HW_H_</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &quot;<a class="code" href="dec__ldpc__bin__hw__iface_8h.html" title="Channel decoder interface.">dec_ldpc_bin_hw_iface.h</a>&quot;</span>
<span class="preprocessor">#include &quot;dec_ldpc_bin_hw_param.h&quot;</span>


<span class="keyword">class </span>Decoder_LDPC_Binary_HW : <span class="keyword">public</span> Decoder_LDPC_Binary_HW_Interface,
                               <span class="keyword">public</span> Decoder_LDPC_Binary_HW_Parameter
{

<span class="keyword">public</span>:
  
  Decoder_LDPC_Binary_HW()
  virtual ~Decoder_LDPC_Binary_HW();

  <span class="keywordtype">int</span> Run();

  
protected:

  <span class="keywordtype">void</span> Init();
  <span class="keywordtype">void</span> Alloc_Mem();
    
private:
  ...
};
<span class="preprocessor">#endif</span>
</pre></div><p>The order of inheritance has to occur in alphabetical order:</p>
<ol type="1">
<li>_Interface</li>
<li>_Parameter</li>
<li>_Share (one or more classes)</li>
</ol>
<p>This results in a fixed positions for classes of the same type within the inheritance diagram generated by doxygen. Thus, it allows for a more intuitive browsing through the documentation.</p>
<p>The Init() function sets derived parameters, resizes the output ports calling Alloc_Mem(), and performs other tasks that are required by the module before it is save to invoke the Run() function. Now class variables and functions can be defined in the private part and the according content of the functions can be included in the body of the class.</p>
<h3><a class="anchor" id="cpp_file"></a>
The module class body (.cpp)</h3>
<p>The module functionalities is implemented in the cpp file. A minimum template of a module body looks like follows:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;dec_ldpc_bin_hw.h&quot;</span>

<span class="keyword">using namespace </span>std;

Decoder_LDPC_Binary_HW::Decoder_LDPC_Binary_HW() { }

Decoder_LDPC_Binary_HW::~Decoder_LDPC_Binary_HW() { }

Decoder_LDPC_Binary_HW::Init()
{
  ...
  Alloc_Mem();

  <span class="comment">// Set the config-variables to false after initialization.</span>
  param_list_.config_modified(<span class="keyword">false</span>);
  input_data_list_.port_modified(<span class="keyword">false</span>);
}

Decoder_LDPC_Binary_HW::Alloc_Mem()
{
}

Decoder_LDPC_Binary_HW::Run()
{
  <span class="keywordflow">if</span>(param_list_.config_modified() || input_data_list_.port_modified())
    Init();

  Decoder_Function_Call();
}
</pre></div><p> The if statement in the Run function is mandatory. It allows for an automatic run of the Init function if a parameter or port has changed.</p>
<h2><a class="anchor" id="doc"></a>
Documentation of the Module</h2>
<p><b> Remember to document the interfaces, the parameters, and the functionality of the modules with doxygen comments such that other users can use your module! </b> Use the normal C++ comments for the rest of your code. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
